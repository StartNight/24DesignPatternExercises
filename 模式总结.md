## 模式总结

### 简单工厂模式 不符合开放-封闭原则的精神 因为:每一次扩展时都要更改工厂类,就是修改开放了,当然不符合开放原则.

### 单一职责

### 开放封闭

### 依赖倒转

### 里氏代换

### 合成复用

### 迪米特


## 创建型模式

### 抽象工厂
> 提供一个创建一系列或相关依赖对象的接口,而无需指定它们的具体类.

### 建造者
> 将一个复杂对象的构建与它的表示分离,是的同样的构建过程可以创建不同的表示.

### 工厂方法
> 定义一个用于创建对象的接口,让子类决定实例化那一个类,工厂模式使一个类的实例化延迟到其子类.

### 原型
> 原型实例指定对象的种类,并且通过拷贝这样原型创建新的对象.

### 单例
> 保证一个类仅有一个实例,并提供一个全局访问它的全局访问点.

### 总结
- 创建型模式隐藏了这些类的实例是如何被创建和放在一起,整个系统关于这些对象所知道的是由抽象类所定义的接口.这样创建型模式在创建什么,谁创建它,它使怎么创建的,以及何时创建这些方面提供了很大的灵活性.
- 建立相应数目的原型并克隆它们通常比每次用适合的状态手工实例化该类更方便一些.
- 内聚性和耦合性的问题,内聚性描述的是一个例程内部组成的部分之间相互联系的紧密程度.而耦合性描述的是一个例程:内部完整,也就是高内聚,而与其他例程之间的联系则是小巧,直接,可见,灵活的,这就是松耦合.
- 松耦合,将一个复杂的对象的构建与它的表示分离,用同样的构建过程创建不同的产品给客户.
- 对一些类来说,一个实例是很重要的.让类自身负责保存它的唯一实例.这个类可以保证没有其他实例可以被创建,并且我还提供了一个访问该实例的方法.这样对唯一的实例可以严格的控制客户怎么以及何时访问它.
- 创建型模式抽象了实例化的过程.它们帮助一个系统独立如何创建,组合和表示它的哪些对象.创建型模式都会将关于该系统使用哪些具体的类的信息封装起来.允许客户用结构和功能差别很大的产品对象配置一个系统.配置可以是静态的,即在编译时指定,也可以是动态的,就是运行时再指定.
- 通常设计模式应该是从工厂方法开始,当设计者发现需要更大灵活性时,设计便会向其他创建型模式演化.当设计者在设计标准之间进行权衡的时候,了解更多创建模式可以给设计者等多的选择余地.

## 结构型模式
### 适配器
> 将一个类的接口转换成客户希望的另一个接口.适配器模式使得原来由于接口不兼容而不能一起工作的那些类可以一起工作.

### 桥接
> 将抽象部分与它的现实部分分离,使它们都可以独立地变化.

### 组合
> 将对象组合成树形结构以表示"部分-整体"的层次结构,组合模使得用户对单个对象和组合对象的使用具有一致性.

### 装饰
> 动态的给一个对象添加一些额外的职责.就增加功能来说,装饰模式相比生成子类更加灵活.

### 外观
> 为子系统中的一组接口提供一个一致的界面,外观模式定义了一个高层接口,这个接口使得这一子系统更加容易使用.

### 享元
> 为运用共享技术有效地支持大量细颗粒的对象.

### 代理
> 为其他对象提供一种代理以控制对这个对象的访问.
## 总结
- 适配器,想使用一个已经存在的类,而它的接口不符合要求,或者希望创建一个可以复用的类,该类可以与其他不相关的类或不可预见的类协同工作.让这些接口不同的类通过适配后,协同工作.
- 桥接,继承是个好东西,但是往往过度使用,继承会导致类的结构过于复杂,关系太多,难以维护,而更糟糕的是扩展性非常差.解耦这些不同方向的变化,通过组合的方式,把两个角色之间的继承关系改为了组合的关系,从而使着两者可以应对各自独立的变化.找出变化并封装之.
- 装饰,可以更加灵活,,以动态透明的方式给单个对象添加职责,并在不需要时,撤销相应的职责.
- 组合模式的效果是客户可以一致地使用组合结构和单个对象.任何用到基本对象的地方都可以使用组合对象.
- 外观,类和类之间的耦合越弱,越有利复用,一个处在弱耦合和类被修改,不会对有关系的类造成波及.如果两个类不必彼此直接通信,那么就不要让这两个类发生直接的相互作用.如果实在需要调用,可以通过第三者转发调用.让软件中的子系统间的通信和相互依赖关系到达最小,而具体办法就是引入一个外观对象,它为子系统间提供了一个单一而简单的屏障.通常企业软件的三层或N层架构,层与层之间的分离其实就是外观模式的体现.
- 享元,对象使得内存占用过多,而且如果都是大量的重复对象,那就是资源的极大浪费,,可以共享对象,节约内存.
- 代理,代理与外观主要区别在于,代理对象代表一个单一对象而外观对象代表一个子系统;代理对象的客户对象无法直接访问目标对象,由代理提供对单独的目标对象的访问控制,而外观的客户对象可以直接访问子系统中的各个对象,但通常由外观对象提供子系统各元件功能的简化的共同层次的调用接口.代理是一种原来对象的代表,其他需要与这个对象打交道的操作都是这个代表交涉.而适配器侧不需要虚构出一个代表者,只需要为应付特定使用目的,将原来的类进行一些组合.
- 适配器,主要为了解决两个已有接口之间不匹配的问题,我不需要考虑这些接口是怎样实现的,也不考虑他们各自可能会如何演化.我的这种方式不需要对两个独立设计的类中任一个进行重新设计,就能够使它们协同工作.
- 桥接和适配器是被用于软件生命周期的不同阶段,针对不同的问题,谈不上孰优孰劣.
## 行为模式一
### 观察者
> 定义对象见的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新.
### 模板
> 定义一个操作的算法骨架,而将一些步骤延迟到子类中,模板方法使得子类可以不改变一个算法的结构即可重定义该方法的某些特定步骤.
### 命令
> 将一个请求封装为一个对象,从而使得你可用不同的请求对客户进行参数化,可以对请求排队或记录请求日志,以及支持撤销的操作.
### 状态
> 允许一个对象在其内部状态改变时改变它的行为,让对象看起来似乎修改了它的类.
### 职责链
> 使多个对象都有机会处理请求,从而避免请求的发送者喝接收者之间的耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止.

## 总结
- 模板方法,代码重复是编程中最常见,最糟糕的'坏味道',如果我们在一个以上的地方看到相同的程序结构,那么可以肯定,设法将它们合而为一,程序会变得更好.但是完全相同的代码当然存在明显的重复,而微秒的重复会出现在表面不同但是本质相同的结构或处理步骤中.模板方法由一个抽象类组成,当这个抽象类定义了需要覆盖的不同实现的模板方法,每个从这个抽象类派生的具体类将为此模板实现新方法.
- 命令模式,可以在不同的时刻,排列和执行请求.支持取消.重做的操作.可以记录整个操作日志,支持事物.
- 职责链模式,有多个对象可以处理一个请求,哪个对象处理该对象请求事物并不知道,要在运行时刻自动确定,让客户在不明确指定接收者的情况下,提交一个请求,然后由所有能处理这请求的对象生成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止.
- 状态模式提供了一个更好的办法来组织与特定状态相关的代码,决定状态转移的逻辑不在单块的if或switch中,而是分布在各个状态子类之间,由于所有的状态相关的代码都存在于某个状态子类中,所以通过定义新的子类可以很容易地增加新的状态和转换.
- 额外点:MVC是包括三类对象,Model是应用对象,View是它在屏幕上的表示,Controller定义用户界面输入的响应方式.如果不是使用MVC,则用户界面设计往往将这些对象混在一起,而MVC则将它们分离以提高灵活性和复用性.MVC是多种模式的综合应用,应该算是一种架构模式.
## 行为模式二
### 解释器
> 给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用来解释语言的句子.
### 中介者
> 用一个中介对象来封装一系列的对象交互.中介者使各对象不需要显式的相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互.
### 访问者
> 表示一个作用于某对象结构中的各元素的操作.它使你可以在不改变各元素的类前提下定义作用于这些元素的新操作.
### 策略
> 定义一系列的算法,把它们一个个封装起来,并且使它们可以相互替换.本模式使得算法可以独立于使用它的客户而变化.
### 备忘录
> 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可以将该对象恢复到原先保存的状态.
### 迭代器
> 提供一个种方法顺序访问一个聚合对象中各个元素,而又不需要暴露该对象的内部表示.

##总结

- 解释器如果一种特定类型的问题发生的频率足够高,那么就可以考虑将这些问题的各个实例表述为一个简单语言中的句子,也就是说,通过构建一个解释器,该解释器解释这些句子来解决该问题.
- 中介者模式,面向对象设计鼓励将行为分布到各个对象中,这种分布可能导致对象间有许多连接.也就是说有可能每一个对象都需要知道其他许多对象.对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作,这对于应对变化是不利的.任何较大的改动都很困难.将集体行为封装一个单独的中介者对象来避免这个问题,中介者负责控制和协调一组对象间的交互.中介以使组中的对象不再相互显式引用.最少知识原则,就是如何减少耦合的问题,类之间的耦合越弱,越有利于复用.
- 访问者增加具体的Element是困难的,但增加依赖于复杂对象结构的构建的操作就边的容易,仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作.继承提供了一种支持多算法或行为的方法,我们可以直接生成一个类A的子类B,C,D从而给他不懂的行为.但是这样会将行为硬件编制到父类A当中,而将算法的实现与类A的实现混合起来,从而使得类A难以理解,难以维护扩展,而且还不能动态地改变算法.仔细分析会发现,它们之间的唯一差不是它们使用的算法或行为,将算法封装在独立的策略Strategy类中使得你可以独立于其类A改变它,使它易于切换,易于理解,易于扩展.备忘录,可以避免暴露一些只应用由对象A管理又必须存储在对象A之外的信息.
- 备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来,从而保持了封装边界.
- 迭代器模式的关键思想是将对列表的访问和遍历从列表中分离出来并放入一个迭代器对象中,迭代器类定义了一个访问该列表元素的接口.迭代器对象负责跟踪当前的元素,并且知道哪些元素已经遍历过了.
- 工厂方法,只要是在做面向对象的开发,创建对象的工作不可避免.创建对象时,负责创建的实体通常需要了解创建的是哪个具体的对象,以及何时创建这个而非那个对象的规则.而我们如果希望遵循开发-封闭原则,依赖倒转原则和里氏代换原则,那使用对象时,就不应该知道所用的是哪一个特选的对象.此时就需要'对象管理者'工厂来负责此事.
- 在创建对象时,使用抽象工厂,原型,建造者的设计比使用工厂方法要灵活,但它们也更加复杂,通常,设计是以使用工厂方法开始,当设计者发现需要更大的灵活性,设计便会向其他创建模式演化.工厂方法的实现并不能减少工作量.但是他能够在必须处理新情况时,避免使已经很复杂的代码更加复杂.
- 面向对象设计模式体现的就是抽象的思想,类是对对象的抽象,抽象类呢,其实就是对类的抽象,那接口呢,说白了就是对行为的抽象.



### 摘抄
- 简洁就是美
- 高内聚,低耦合
- 通常设计时,应该从工厂方法开始.
- 生活还在继续,编程也不会结束.